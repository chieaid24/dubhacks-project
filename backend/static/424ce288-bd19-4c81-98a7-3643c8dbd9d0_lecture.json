[
  {
    "page_number": 1,
    "slide_text": "So far, we've discussed how our programs run in user space. But what happens when a program needs to interact with the outside world, or request a service from the operating system itself? That's where **System Calls** come in. These are the fundamental interface between your user-level code and the kernel. Think of them as explicit requests to the OS: for instance, if your program wants to open a file, it doesn't just do it directly. It makes a `read` or `write` *system call*, which then causes the kernel to perform the actual operation on the hardware.\n\nIn this course, we'll extensively use **POSIX I/O**, which refers to a standard set of system calls and library functions for input and output operations, defined by the Portable Operating System Interface (POSIX) standard. This standard ensures that code written to these interfaces behaves predictably across different Unix-like systems. Common examples you'll encounter are functions like `open()`, `read()`, `write()`, and `close()`. These are the low-level, unbuffered functions that directly interact with file descriptors, giving us fine-grained control over file operations. Understanding them is crucial for robust and efficient system programming in C."
  },
  {
    "page_number": 2,
    "slide_text": "Alright everyone, welcome back to CSE333. Today, we're diving into Lecture 7, focusing on **System Calls and POSIX I/O**, which are foundational concepts for interacting with the operating system.\n\nBut first, let's quickly cover some administrivia.\n\nYour **EX6 is due today**, so please make sure your solutions are submitted. Looking ahead, **EX7 will be released this Friday**. We encourage you to take a brief breather, perhaps over the weekend, before jumping into it. Do note, however, that EX7 will heavily involve the material we're covering in today's lecture on System Calls, and the practical aspects we'll explore further in tomorrow's section.\n\nCrucially, **HW1 is due at midnight tomorrow**. Regarding submission, please remember that your official submission time for HW1 is the timestamp of the **`hw1-final` git commit tag**. So, ensure you've pushed that specific tag before the deadline. And if you happen to need a late day token, don't worry about notifying us; they'll be applied automatically if your submission is late, so you don't need to take any extra steps.\n\nWith that out of the way, let's turn our attention to System Calls..."
  },
  {
    "page_number": 3,
    "slide_text": "Alright, so we're diving into System Calls and POSIX I/O today, but before we get there, let's ensure we're all on the same page about the fundamental component that makes all of this possible: What *is* an Operating System, anyway?\n\nAt its core, an OS is a special piece of software with three main roles. First, it's the *only* software trusted to directly interact with your computer's hardware. Think of it like a privileged manager. Your user-level programs, such as a web browser or a word processor, aren't allowed to directly talk to the disk or the network card; the OS mediates that. This is why the OS itself must be \"ported\" or adapted for each new hardware architecture, while your applications generally remain portable.\n\nSecond, the OS is responsible for managing all your hardware resources \u2013 allocating them, scheduling access, and protecting them. For instance, it decides which program gets to use the CPU when, which application can write to a specific file, or which program's pixels appear on the screen at any given moment.\n\nFinally, the OS simplifies things by abstracting away the messy details of hardware. Instead of dealing with raw electrical signals or complex disk geometry, the OS provides high-level, convenient, and portable abstractions like 'files,' 'directories,' or 'disk blocks,' making programming much easier and applications hardware-independent."
  }
]